from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
from typing import Any, Dict, List, Optional

from smell_repair.project.java_extract import ExtractedContext
from smell_repair.llm.evidence import evidence_block_markdown, render_evidence_for_prompt


SYSTEM_PROMPT = """You are an expert Java developer.
You will be given a JUnit4 test method generated by EvoSuite and relevant production-code context.
Your task is to refactor/repair the test to reduce the provided Smelly test smells.

Hard rules:
- DO NOT delete the test method or test class.
- DO NOT add @Ignore or disable the test.
- Keep the test compiling.

Output format:
- Return ONLY the complete refactored test method code (including @Test annotation and method signature).
- Do NOT return a diff.
- Do NOT include markdown/code fences or any extra text.
"""


@dataclass(frozen=True)
class PromptInputs:
    smells: List[str]
    smell_guides: str
    smell_evidence: Dict[str, Any]
    allow_reflection_asserts: bool
    file_relpath: str
    ctx: ExtractedContext
    limits: Optional["PromptLimits"] = None
    compile_error: Optional[str] = None


@dataclass(frozen=True)
class PromptLimits:
    max_smell_guides_chars: int = 12000
    max_evidence_chars: int = 8000
    max_test_method_chars: int = 8000
    max_cut_context_chars: int = 12000
    max_compile_error_chars: int = 4000
    evidence_max_list_items: int = 6
    evidence_max_group_tests: int = 10
    evidence_max_prefix_stmts: int = 2
    evidence_max_str_len: int = 240


def load_smell_guides(smells_dir: Path, smell_ids: List[str]) -> str:
    parts: List[str] = []
    for sid in smell_ids:
        p = smells_dir / f"{sid}.md"
        if p.exists():
            parts.append(p.read_text(encoding="utf-8", errors="ignore"))
    return "\n\n".join(parts)


def _truncate_section(text: str, max_chars: int) -> str:
    if max_chars <= 0 or len(text) <= max_chars:
        return text
    return text[:max_chars].rstrip() + "\n... [truncated]"


def build_messages(inp: PromptInputs) -> List[Dict[str, str]]:
    limits = inp.limits or PromptLimits()
    allow_reflect = "ALLOWED" if inp.allow_reflection_asserts else "NOT ALLOWED"

    evidence_sections: List[str] = []
    for sid in inp.smells:
        ev = (inp.smell_evidence or {}).get(sid)
        if not ev:
            continue
        evidence_sections.append(
            evidence_block_markdown(
                render_evidence_for_prompt(
                    sid,
                    ev,
                    max_list_items=limits.evidence_max_list_items,
                    max_group_tests=limits.evidence_max_group_tests,
                    max_prefix_stmts=limits.evidence_max_prefix_stmts,
                    max_str_len=limits.evidence_max_str_len,
                )
            )
        )
    evidence_text = _truncate_section("\n\n".join(evidence_sections).strip(), limits.max_evidence_chars)

    smell_guides = _truncate_section(inp.smell_guides, limits.max_smell_guides_chars)
    test_method_code = _truncate_section(inp.ctx.test_method_code, limits.max_test_method_chars)
    cut_context = _truncate_section(inp.ctx.cut_relevant_code, limits.max_cut_context_chars)

    user = f"""Smells to address: {', '.join(inp.smells)}
Reflection-based assertions: {allow_reflect}

Output requirement:
- Return ONLY the complete refactored method code for {inp.ctx.test_method_name}.
- Do NOT include any other text, diff, or code fences.

Smell guides:
{smell_guides}

=== Smelly evidence (extended JSON, compact & prioritized) ===
{evidence_text if evidence_text else '(no evidence provided)'}

=== Target Java file (relative path) ===
{inp.file_relpath}

=== Test class ===
{inp.ctx.test_class_name}

=== Test method (focus) ===
{inp.ctx.test_method_name}

=== Test method source ===
```java
{test_method_code}
```

=== Production code context (CUT + related methods, best-effort) ===
CUT: {inp.ctx.cut_fqcn or 'UNKNOWN'}
```java
{cut_context}
```
"""

    if inp.compile_error:
        compile_error = _truncate_section(inp.compile_error, limits.max_compile_error_chars)
        user += f"""

=== Previous attempt failed compilation/test ===
```
{compile_error}
```
Please fix the issues and re-output ONLY the complete refactored method code for {inp.ctx.test_method_name}.
"""

    return [
        {"role": "system", "content": SYSTEM_PROMPT},
        {"role": "user", "content": user},
    ]
