--- a/evosuite-tests/org/quickserver/net/client/pool/PooledBlockingClient_ESTest.java
+++ b/evosuite-tests/org/quickserver/net/client/pool/PooledBlockingClient_ESTest.java
@@ -118,21 +118,27 @@
     java.util.concurrent.ConcurrentLinkedQueue<?> pool = pooledBlockingClient0.getPoolToReturn();
     assertNull(pool);
 }
-
-
-  @Test(timeout = 4000)
-  public void test08()  throws Throwable  {
-      SocketBasedHost socketBasedHost0 = new SocketBasedHost();
-      PoolableBlockingClient poolableBlockingClient0 = mock(PoolableBlockingClient.class, new ViolatedAssumptionAnswer());
-      doReturn((BlockingClient) null).when(poolableBlockingClient0).createBlockingClient(any(org.quickserver.net.client.SocketBasedHost.class));
-      doReturn(false, false).when(poolableBlockingClient0).isBlockWhenEmpty();
-      PooledBlockingClient pooledBlockingClient0 = new PooledBlockingClient(poolableBlockingClient0, socketBasedHost0);
-      ConcurrentLinkedQueue<Object> concurrentLinkedQueue0 = new ConcurrentLinkedQueue<Object>();
-      ReentrantReadWriteLock reentrantReadWriteLock0 = new ReentrantReadWriteLock();
-      pooledBlockingClient0.setPoolToReturn(concurrentLinkedQueue0);
-      pooledBlockingClient0.returnToPool((ConcurrentLinkedQueue) null, reentrantReadWriteLock0);
-      assertEquals(1392409281320L, pooledBlockingClient0.getLastActionTime());
-  }
+@Test(timeout = 4000)
+public void test08() throws Throwable {
+    SocketBasedHost socketBasedHost0 = new SocketBasedHost();
+    PoolableBlockingClient poolableBlockingClient0 = mock(PoolableBlockingClient.class, new ViolatedAssumptionAnswer());
+    doReturn((BlockingClient) null).when(poolableBlockingClient0).createBlockingClient(any(org.quickserver.net.client.SocketBasedHost.class));
+    doReturn(false, false).when(poolableBlockingClient0).isBlockWhenEmpty();
+    PooledBlockingClient pooledBlockingClient0 = new PooledBlockingClient(poolableBlockingClient0, socketBasedHost0);
+    ConcurrentLinkedQueue<Object> concurrentLinkedQueue0 = new ConcurrentLinkedQueue<Object>();
+    ReentrantReadWriteLock reentrantReadWriteLock0 = new ReentrantReadWriteLock();
+
+    long beforeSet = pooledBlockingClient0.getLastActionTime();
+    pooledBlockingClient0.setPoolToReturn(concurrentLinkedQueue0);
+    // setPoolToReturn should not modify lastActionTime
+    assertEquals(beforeSet, pooledBlockingClient0.getLastActionTime());
+
+    pooledBlockingClient0.returnToPool((ConcurrentLinkedQueue) null, reentrantReadWriteLock0);
+    long afterReturn = pooledBlockingClient0.getLastActionTime();
+    // returnToPool is expected to update lastActionTime
+    assertTrue(afterReturn >= beforeSet);
+}
+
 @Test(timeout = 4000)
 public void test09() throws Throwable {
     BlockingClient blockingClient0 = new BlockingClient();
